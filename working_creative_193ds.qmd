---
title: "Choose Your Own Assignment: Generative Art Workshop (structured)"
format: 
  html: 
    toc: true
---

**Name: Paige Lund**

**Date: 06-05-24**

## Part 2a: Get set up

Link to GitHub repository: https://github.com/pllund/art-from-code 
Link to rendered .html: https://pllund.github.io/art-from-code/working_creative_193ds.html 

## Part 2b: Introductory Exercises

### Art is Theft Exercise

Try it yourself! Using nothing other than ggplot2 and the mpg data set, create your own artwork. Don’t take too long: 3 minutes at the absolute most! See what you can come up with in that time!

```{r, message=FALSE, warning=FALSE}
#load in necessary packages 
library(tidyverse)
library(tibble)

#load in mpg data and set up ggplot
ggplot(data = mpg, 
       #set aesthetics and select data
       aes(x=hwy, y=drv, colour = drv)) + 
  #select dotplot to show data and set size and color of dots
  geom_dotplot(show.legend = FALSE, size = 3, color = "skyblue") + 
  #select another dotplot data and make size smaller and transparent
  geom_dotplot(show.legend = FALSE, size = 0.5, color = "transparent") + 
  #change orientaion 
  coord_quickmap() + 
  #set color scale
  scale_color_brewer()
```

### Technique Exercises

1.  In the materials folder there is a file called `polar_art.R` that contains a copy of the `polar_art()` function. Open it and use the `polar_art()` function to generate your own pieces. Try changing the `seed`, `n`, and the `palette` to create a variety of different pieces.

```{r, warning = FALSE}
#load in relevant packages
library(ggplot2)
library(tibble)

#assign object name and begin set up for seed process and setting palette
polar_art <- function(seed, n, palette) {
  # set the state of the random number generator
  set.seed(seed)
  # data frame containing random values for 
  # aesthetics we might want to use in the art
  dat <- tibble(
    #set x and y values using runif function
    x0 = runif(n), y0 = runif(n),
    #set x min and max 
    x1 = x0 + runif(n, min = -.2, max = .2),
    #set Y min and max 
    y1 = y0 + runif(n, min = -.2, max = .2),
    #set shading and size features of figure for polar_art
    shade = runif(n), size = runif(n))
  
  #plot segments in various colors, using polar coordinates and a gradient palette
  dat |> 
    #start ggplot and set aesthetics
    ggplot(aes(x = x0, y = y0,
      #set ends for x and y in ggplot
      xend = x1, yend = y1,
      #set color and size ggplot specifications
      colour = shade, size = size)) +
    #apply geom_segment to show data this way and disable legend
    geom_segment(show.legend = FALSE) +
    #make it so that the plot is swirly sort of
    coord_polar() +
    #set y axis to standard
    scale_y_continuous(expand = c(0, 0)) +
    #set x axis to standard
    scale_x_continuous(expand = c(0, 0)) + 
    #set color gradient to use color palette
    scale_colour_gradientn(colours = palette) + 
    #set scale size range and expand this to 10 
    scale_size(range = c(0, 10)) + 
    #set to blank theme
    theme_void()
}

#polar_art code that I altered, changed seed 
polar_art(seed = 81, 
  #changed number of samples
  n = 65, 
  #changed the colors of the plot to shades of pink
  palette = c("hotpink", "pink3", "lightpink")
)

#second polar_art code that I altered to test out different palettes and seeds
polar_art(seed = 45, 
  #changed number of samples
  n = 90, 
  #changed the colors of the plot to shades of pink
  palette = c("blue", "skyblue3", "lightblue")
)
```

2.  Create a new file called `polar_art_02.R` that contains the `polar_art()` function. In the new file, try modifying the `polar_art()` function itself to see if you can create your own new system.

```{r}
#changing the actual polar_art to polar_art_02 to change this aspect of the original code

#use original polar_art for this and edits are reflected in polar_art_02
polar_art <- function(seed, n, palette) {
  #set the seed to get random numbers for data
  set.seed(seed)
  #create new dataframe with the random values 
  dat <- tibble(x0 = runif(n), y0 = runif(n), 
                #CHANGED - alter min and max values to be greater
                x1 = x0 + runif(n, min = -.10, max = .10),
                y1 = y0 + runif(n, min = -.10, max = .10), 
                #set shading for future figures
                shade = runif(n), 
                #set size of shapes for figure
                size = runif(n)
                ) 
  #identify plot segments and denote them in different colors 
  dat |> 
    #set plot aesthetics and x and y values
    ggplot(aes(x = x0,y = y0,xend = x1,yend = y1,
      #change color and size for figures
      colour = shade, size = size)) + 
    #set geom type as segment and make sure legend does not show
    geom_segment(show.legend = FALSE) +
    #CHANGED - change to coord_flip to alter orientation of data
    coord_flip() +
    #set y axis range
    scale_y_continuous(expand = c(0, 0)) +
    #set x axis range
    scale_x_continuous(expand = c(0, 0)) + 
    #set color gradient scale using pallette feature
    scale_colour_gradientn(colours = palette) + 
    #CHANGED - alter size of scale to be larger
    scale_size(range = c(0, 50)) + 
    #CHANGED - set theme to different theme than theme_void
    theme_minimal()
}

#NOTE - this code has been changed as per the exercise instructions to alter the palette, seed, and n values
#change the seed to get different random data
polar_art(seed = 81, 
          #set the sample size to 65
          n = 65, 
          #change the colors of the plot to be shades of pink
          palette = c("hotpink", "pink3", "lightpink"))
```

3.  Something to think about: Usually in data science we try to avoid naming our files `my_file_version_1`, `my_file_version_2`, etc, and instead we place files under version control using git. Yet here I am in an art context, apparently giving the advice to fall back on the old-fashioned system of naming files with version numbers. Why might I be doing that?

Answer: The artist could want to be able to name their files the old-fashioned way in order to keep track of their work and be able to reproduce what they have created and/or add onto their work in the future. Additionally, the files could be named this way in order to represent where they were created from, so the audience knows that the figures are originally from data wrangling in R. 

### Color Exercises

1.  In the materials folder there is a file called `palette-generators.R` that contains a copy of the `sample_canva()` function. Take a look and try calling the function a few times to see what kind of output it produces. You may find it handy to use `show_col()` to visualise the results.

```{r}
#load in necessary package
library(ggthemes)
library(scales)
library(ggplot2)

#the original function from the first session
sample_canva <- function(seed = NULL) {
  #setting random number seeds
  if(!is.null(seed)) set.seed(seed)
  #setting palettes
  sample(ggthemes::canva_palettes, 2)[[5]]
}

#the extended function used in later sessions
sample_canva2 <- function(seed = NULL, n = 10) {
  #setting random number seeds
  if(!is.null(seed)) set.seed(seed)
  #setting canva palettes
  sample(ggthemes::canva_palettes, 10)[[10]] |>
    (\(x) colorRampPalette(x)(n))()  
}

#show the colors to visualize results
canva_palettes[[70]]
#printing results
show_col(canva_palettes[[70]])
```

2.  Try writing your own random palette generator. A simple (and occasionally useful) approach is to construct a palette consisting of distinct but otherwise randomly selected named colours in R. There is a set of 502 colour names generated by calling `colours()` with `distinct = TRUE)`. Write a function called `sample_named_colours()` that takes `n` as an input argument, and then returns a sample of `n` of these colour. Try using it with the `polar_art()` function.

```{r}
#load in relevant package just in case
library(ggthemes)

#write new function similar to sample_canva
sample_named_colors <- function(seed = NULL) {
  #set seed to be random number generation
  if(!is.null(seed)) set.seed(seed)
  #set sample of colors to come from set of 502 possible color names
  sample(colors(distinct = TRUE))}

#use new color generator code for existing code we have for polar art and change seed and n value
polar_art(seed = 76, n = 75, palette = sample_named_colors(seed = 76))
```

3.  The `sample_canva()` function, as I’ve written it, preserves the original structure of the 150 palettes in `ggthemes::canva_palettes`, so that the 4 colours returned all belong to the same palette on the Canva website originally. Try breaking this constraint. If you call `unlist(ggthemes::canva_palettes)` you get a vector of 600 distinct colours. Write a palette generating function that samples colours randomly from that set of 600 colours.

```{r}
#load library for reference
library(ggthemes)

#the original function from the first session
sample_canva <- function(seed = NULL) {
  #set seed to be random number generation
  if(!is.null(seed)) set.seed(seed)
  #set sample of colors to come from set of possible colors
  sample(ggthemes::canva_palettes, 1)[[1]]
}

#the extended function used in later sessions
sample_canva2 <- function(seed = NULL, n = 4) {
  #again set seed to be random number
  if(!is.null(seed)) set.seed(seed)
  #select color from canva_palettes 
  sample(ggthemes::canva_palettes, 1)[[1]] |>
    #identify seed for using colorRampPalette
    (\(x) colorRampPalette(x)(n))()  
}

#use code for setting up seed for sample_canva function 
sample_canva <- function(seed = NULL) {
  #set seed to be random selection again
  if(!is.null(seed)) set.seed(seed)
  #change from just ggthemes to unlist to get vector of 600 colors to sample from
  sample(unlist(ggthemes::canva_palettes), 1)[[1]]
}

#create polar_art figure using random color from sample_canva with seed set to 659
polar_art(seed = 659, n = 600, palette = sample_canva(seed = 659))
```

### Composition Exercises

1.  In the materials folder there is a file called `polar-styled-plots.R` that contains a copy of the `sample_canva()`, `sample_data()` and `polar_styled_plot()` functions. Without modifying any of these three functions, explore how much flexibility you have to make different pieces in which (1) data are generated with `sample_data()`, (2) the plot is initialised by calling `polar_styled_plot()`, and (3) the piece is created by adding ggplot2 geoms. Data manipulation with dplyr is allowed!

```{r}
#load in necessary packages
library(ggplot2)
library(tibble)
library(dplyr)

#using the sample_canva function again and setting seed to null
sample_canva <- function(seed = NULL) {
  #setting up random seed generation
  if(!is.null(seed)) set.seed(seed)
  #choosing where color comes from aka the palette
  sample(ggthemes::canva_palettes, 1)[[1]]
}

#assigning object name and using function for setting seed and number
sample_data <- function(seed = NULL, n = 100){
  #set up random number generation
  if(!is.null(seed)) set.seed(seed)
  #set restrictions for tibble for x and y
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.2, max = .2),
    y1 = y0 + runif(n, min = -.2, max = .2),
    shade = runif(n), 
    size = runif(n),
    shape = factor(sample(0:22, size = n, replace = TRUE))
  )
}

#not modified
polar_styled_plot <- function(data = NULL, palette) {
  ggplot(
    data = data,
    mapping = aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) + 
    coord_polar(clip = "off") +
    scale_y_continuous(
      expand = c(0, 0),
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) +
    scale_x_continuous(
      expand = c(0, 0), 
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 10)) + 
    theme_void() + 
    guides(
      colour = guide_none(),
      size = guide_none(),
      fill = guide_none(),
      shape = guide_none()
    )
}

#change the sample data called by changing the number of datapoints and changing the seed number
dat <- sample_data(n = 96, seed = 45) |>
  #mutate to change size by dividing by two 
  mutate(y1 = y0, size = size/2)
#change seed number (same as new seed number in above line of code) 
pal <- sample_canva(seed = 45)

#create new plot of this alternative data 
polar_styled_plot(data = dat, palette = pal) + 
  #use geom_segment to create image and change size to be smaller
  geom_segment(size = 1) + 
  #create second geom of different lines and make these much larger
  geom_path(size = 5)
```

2.  In the examples above and the previous exercise you saw that the `polar_styled_plot()` function plays the role of defining an overarching “style” for possible art pieces, but it doesn’t completely constrain artistic freedom. Your task in this exercise is to try to write a `my_styled_plot()` that does something similar… but creates a different style that you can explore

```{r, warning=FALSE}
#sample palete a random using seed 
sample_canva <- function(seed = NULL) {
  #set seed and restrictions
  if(!is.null(seed)) set.seed(seed)
  #select palette to use
  sample(ggthemes::canva_palettes, 1)[[1]]}

#generate random numbers using tibble and set seed and number of samples
sample_data <- function(seed = NULL, n = 100){
  #determine seeds setting
  if(!is.null(seed)) set.seed(seed)
  #set restrictions for tibble for x and y
  dat <- tibble(x0 = runif(n),y0 = runif(n),
    #set min and max x values
    x1 = x0 + runif(n, min = -.2, max = .2),
    #set min and max y values
    y1 = y0 + runif(n, min = -.2, max = .2),
    #assign shading and size for samples
    shade = runif(n), size = runif(n),
    #assign shape and size for data
    shape = factor(sample(0:22, size = n, replace = TRUE)))}

#modified version of polar_styled_plots to be my_styled_plots
my_styled_plot <- function(data = NULL, palette) {
  ggplot(data = data,mapping = aes(x = x0,y = y0,
      xend = x1,yend = y1,
      colour = shade, size = size)) + 
    #CHANGED - switched to coord_fixed and ratio set at 100
    coord_fixed(ratio = 100) +
    #CHANGED - made limits greater 
    scale_y_continuous(expand = c(0, 0),limits = c(0, 50),oob = scales::oob_keep) +
    #CHANGED - made limits greater
    scale_x_continuous(expand = c(0, 0), limits = c(0, 50),oob = scales::oob_keep) + 
    #set color gradient to palette we chose
    scale_colour_gradientn(colours = palette) + 
    #CHANGED - change size of scale range to be larger
    scale_size(range = c(0, 85)) + 
    #CHANGED - altered theme to have more background
    theme_light() + 
    #set color guides to none
    guides(colour = guide_none(),
      #set size, fill, and shape arguments for guides function
      size = guide_none(), fill = guide_none(), shape = guide_none())}

#changed the sample data called by changing the number of datapoints and changing the seed number
dat <- sample_data(n = 96, seed = 45) |>
  #mutate to change size by dividing by two 
  mutate(y1 = y0, size = size/2)
#change seed number (same as new seed number in above line of code) 
pal <- sample_canva(seed = 45)

#create new plot of this alternative data 
polar_styled_plot(data = dat, palette = pal) + 
  #CHANGED - enlarge data to make it unrecognizable from before
  geom_segment(size = 500) + 
  #create second geom of different lines and make these much larger
  geom_path(size = 5) + 
  #create blue line as curve of data
  geom_smooth(aes(group = 1), method = "loess", se = FALSE)

```

## Part 2c: Art Of Your Choice Exercises: Spatial Noise 


### Sampling Spatial Patterns Exercise

```{r, message=FALSE, warning=FALSE}
#load in necessary packages
library(dplyr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggthemes)
library(ambient)
```

Exercise: Try it yourself! In the materials folder there is a file called `first-ambient-art.R` that reproduces the code above. Try playing around with it to see what kind of output you can create by changing the values fed to `gen_perlin()`, or by trying other generator functions!

```{r}
#simple function to generate random palettes
sample_canva <- function(seed = NULL) {
  #set seed to be random generation
  if(!is.null(seed)) set.seed(seed)
  #CHANGED - set palette for randomly selected data
  sample(ggthemes::canva_palettes, 98)[[98]]
}

#define the spatial grid of x coordinates
x_coords <- seq(from = 0, to = 1, length.out = 600)
#define the spatial grid of y coordinates
y_coords <- seq(from = 0, to = 1, length.out = 600)
#combination of coordinate data in new dataframe
canvas <- long_grid(x = x_coords, y = y_coords) 

#set spatial frequency
freq_spatial <- 10
#set information for spatial seed
seed_spatial <- 100
#set palette for seed 
seed_palette <- 101

#create new art project essentially 
dat <- canvas |> 
  #mutate so that we can add gen_perlin function to new canvas
  mutate(
    #CHANGED from gen_perlin to gen_simplex to display different way 
    paint = gen_simplex(
      #set x and y values
      x = x, 
      y = y, 
      #set figure frequency 
      frequency = freq_spatial, 
      #set seed for figure
      seed = seed_spatial
    )
  )
  
#show picture and create new figure from information we gathered
pic <- dat |>
  #use ggplot function and set aesthetics and fill information
  ggplot(aes(x, y, fill = paint)) + 
  #insert geom_raster to display the data
  geom_raster(show.legend = FALSE) +
  #set specific theme
  theme_void() + 
  #set coord_equal value to nothing
  coord_equal() +
  #set x and y axis 
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  #set scale fill gradient to determine colors of plot
  scale_fill_gradientn(
    colours = sample_canva(seed_palette)
  )

#print the picture we have created above in pic 
plot(pic)
```

### Our First System Exercises

Exercises:

1.  In the materials folder there is a file called make-noise-art.R that includes the make_noise_art() function. Unlike the code I’ve shown here, the version in the script writes the output to a file (located at output/noise-art.png). Try playing around with the inputs to make_noise_art() to see what outputs you can create.

```{r}
#install new package for this section
library(here)

#copy from what we have been doing before
sample_canva <- function(seed = NULL) {
  #set up random seed generation
  if(!is.null(seed)) set.seed(seed)
  #set palette theme
  sample(ggthemes::canva_palettes, 1)[[1]]
}

#set up art and assign colors to use
make_noise_art <- function(
    #change the gen function used
    generator = gen_waves, 
    #alter the frequency from what it used to be
    frequency = 80, 
    #change the number for the seed
    seed = 45,
    #change the number of pixels
    pixels = 500,
    #select color palette 
    palette = c("blue3", "purple2", "violet", "hotpink"), 
    ...
) {
  
  #define the grid
  canvas <- long_grid(
    #set x and y values and the type of pixels
    x = seq(from = 0, to = 1, length.out = pixels),
    y = seq(from = 0, to = 1, length.out = pixels)
  ) 
  
  #use the generator to add paint
  canvas <- canvas |>
    #use paint within the mutate function and generate frequency
    mutate(paint = generator(x, y, frequency = frequency, 
        #set seed information for later
        seed = seed, 
        ...
      )
    )
  
  #use ggplot2 to draw the picture
  art <- canvas |> 
    #begin ggplot and set basic aesthetics information 
    ggplot(aes(x, y, fill = paint)) + 
    #add data using geom_raster
    geom_raster(show.legend = FALSE) +
    #set blank theme
    theme_void() +
    #set coordinates
    coord_equal() +
    #set x axis scale
    scale_x_continuous(expand = c(0, 0)) +
    #set y axis scale
    scale_y_continuous(expand = c(0, 0)) +
    #set color gradient to use palette colors
    scale_fill_gradientn(colours = palette)
  #return figure
  return(art)}

#call make_noise_art with idiosyncratic parameters
art <- make_noise_art(
  #CHANGED - alter the gen function that is used 
  generator = gen_worley,
  #set seed for figure
  seed = 1000, 
  #set color palette for figure
  palette = sample_canva(100),
  #assign value for distance
  value = "distance",
  #set number of pixels
  pixels = 1000)

#save the plot to file with a generic file name
ggsave(
  #name the file and assign where it will go
  filename = here("output", "noise-art-2.png"), 
  #define what the ggsave is
  plot = art,
  #set width of figure
  width = 50,
  #set height of figure
  height = 50,
  #set pixel units of figure
  units = "px",
  dpi = 300)

#print what I created in the above code and what is in the file noise-art-2.png
plot(art)

```

2.  At the moment, the script is set up so that the output is always written to the same file, output/noise-art.png. When you create your own generative art systems you will want to ensure that each unique output is written to a file with a unique filename, and that this filename should (ideally!) allow you to work out what inputs were used to create the piece. How would you write code to do this?

```{r}
#In order to write the code to do this you just need to change the name of the file within the ggsave function under filename... so in the code below I changed the code to be different and commented it out for reference. 

#ggsave(
  #name the file and assign where it will go
  #filename = here("change the output here", "make this any different name.png"), 
  #define what the ggsave is
  #plot = art,
  #set width of figure
  #width = 50,
  #set height of figure
  #height = 50,
  #set pixel units of figure
  #units = "px",
  #dpi = 300)
```

### Why dplyr is a Girls Best Friend Exercises

Exercise: Try it yourself! In the materials folder there is a script called dplyr-ambient.R that defines blank_canvas and plot_painted_canvas() for you. At the bottom of the file there is space for you to add to the blank canvas. Try using dplyr and ambient together to create a spatial noise pattern of your own.

```{r}
#load in data for sample_canva and set seed 
sample_canva <- function(seed = NULL) {
  #set up seed system for random generation
  if(!is.null(seed)) set.seed(seed)
  #select sample for where colors come from for palettes
  sample(ggthemes::canva_palettes, 1)[[1]]
}

#create new dataframe using long_grid function 
blank_canvas <- long_grid(
  #set x sequencing and lenght
  x = seq(from = 0, to = 56, length.out = 400),
  #set y sequencing and lenght
  y = seq(from = 0, to = 56, length.out = 400)
) 

#create dataframe for plot of painted canvas information 
plot_painted_canvas <- function(canvas, palette = NULL) {
  #define palette as is.null 
   if(is.null(palette)) {
     #set colors that I want to use for the figure
    palette <- c("green","green3","green2","")
   }
  #create second pipe for canvas
  canvas |> 
    #add in ggplot information and aesthetics for x and y 
    ggplot(aes(x, y, fill = paint)) + 
    #add in data and hide legend
    geom_raster(show.legend = FALSE) +
    #set blank theme
    theme_void() +
    #set coordinates
    coord_equal() +
    #set x axis
    scale_x_continuous(expand = c(0, 0)) +
    #set y axis
    scale_y_continuous(expand = c(0, 0)) +
    #set scale fill to palette
    scale_fill_gradientn(colours = palette)
}

#my code here! adding to the blank canvas 
blank_canvas |> 
  #mutate data to add in different frequencies
  mutate(
    #use gen_waves to alter figure
    lf_noise = gen_waves(x, y, frequency = 4),
    #change frequency from above
    mf_noise = gen_waves(x, y, frequency = 16),
    #set another new frequency
    hf_noise = gen_waves(x, y, frequency = 112),
    #get gate for gen_simplex and assign x and y and frequency
    gate = gen_simplex(x, y, frequency = 8) |> normalise(),
    #set paint for lf_noise information 
    paint = lf_noise +
      #set numerical values for this constraint
      (6 + mf_noise) * (gate >= .5 & gate < .01) +
      #set numerical values for this constraint
      (6 + hf_noise) * (gate >= .01)
  ) |>
  #plot the data from information above 
  plot_painted_canvas(palette = sample_canva(seed = 498))
```

### Fractals Exercises

The fractal_art.R script in the materials folder contains all the setup you need to play around with the fractal_art() function. Try using it to explore the possibilities! There are a lot of possibilities in fractals. Here are a few ideas to get you started:

Exercises:

1.  The easiest way to play around with fractals is to modify the basic arguments. Try changing the generator, fractal, freq_init (i.e., frequency value for the first octave), octaves, seed, and palette to make a piece you really like.

```{r}
#new packaage perhaps
library(purrr)

#again using sample_canva as object name 
sample_canva <- function(seed = NULL) {
  #setting seed random generation
  if(!is.null(seed)) set.seed(seed)
  #setting color palettes
  sample(ggthemes::canva_palettes, 1)[[1]]
}

#set to blank canvas and using long_grid for figure
blank_canvas <- long_grid(
  #set x sequence and lenght
  x = seq(from = 0, to = 1, length.out = 2000),
  #set y sequence and lenght
  y = seq(from = 0, to = 1, length.out = 2000)
) 

#plot the painted canvas data and use canvas and palette within function
plot_painted_canvas <- function(canvas, palette = NULL) {
  #set pallete within null
  if(is.null(palette)) {
    #define exact colors within the palette of my choice
    palette <- c("#e5ddc8","#01949a","#004369","#db1f48")
  }
  #set canvas for new pipe
  canvas |> 
    #begin new ggplot and set aesthetics
    ggplot(aes(x, y, fill = paint)) + 
    #add data using geom_raster and no legend
    geom_raster(show.legend = FALSE) +
    #blank theme
    theme_void() +
    #set coordinates
    coord_equal() +
    #set x axis
    scale_x_continuous(expand = c(0, 0)) +
    #set y axis
    scale_y_continuous(expand = c(0, 0)) +
    #set fill to our defined color palette
    scale_fill_gradientn(colours = palette)
}

#set fractal art as object name and use fractal and generator within function 
fractal_art <- function(fractal, generator, palette = NULL, ...) {
  #set blank canvas and continue pipe
  blank_canvas |>
    #mutate function for paint, noise, and now fractal setting x and y to correct columns
    mutate(paint = fracture(noise = generator, fractal = fractal, x = x, y = y, 
        ...
      )
    ) |>
    #plot the outputted data and show colors
    plot_painted_canvas(palette = palette)
}

#change it to be something I really like by altering the aspects identified in question
fractal_art(fbm, gen_spheres, seed = 78, octaves = 90)
```

2.  A fun inversion: use those same arguments to create something that you find incredibly ugly!

```{r}
#changing same aspects to make it really ugly
fractal_art(fbm, gen_checkerboard, seed = 54, octaves = 3)
```

3.  The fractal_art() function is written flexibly enough that you can pass your own gain functions and frequency functions. There’s an example of this above. Try writing your own functions to modify the gain and frequency rules that apply to the fractal.

```{r}
#assigning new object name and multiplying by 05
gf <- function(x) x * .05
#creating new picture using rigied and gen_simplex and new seeds and octaves settings
fractal_art(ridged, gen_simplex, seed = 54, octaves = 4, gain = gf)
```

4.  Using the gen_scope() and gen_gate() examples to motivate you, write your own generator function. See what effect that has.

```{r}
#use new function to write new generator function 
gen_scope <- function(x, y, frequency, ...) {
  #set generator to speheres and set frequency
  lf <- gen_spheres(x, y, frequency = frequency, ...)
  #more set up for generator function and frequency at 2
  mf <- gen_spheres(x, y, frequency = frequency * 2, ...)
  #more set up for generator function and new frequency
  hf <- gen_spheres(x, y, frequency = frequency * 4, ...)
  #more set up for generator function and largest freqency
  gate <- gen_spheres(x, y, frequency = frequency * 6, ...) 
  #set gate to normalise it
  gate <- normalise(gate)
  #set paint information 
  paint <- lf + 
    #set values for gate and changed this around 
    (mf + 2) * (gate >= .05 & gate < .05) + 
    #changed this around too to see what would happen 
    (hf + 2) * (gate >= .5)
  #show output 
  return(paint)
}

#set seed for colors
pal <- sample_canva(seed = 14)

#show fractal based art and identify billow within the code and set seed and octaves again
fractal_art(billow, gen_scope, palette = pal, seed = 15, octaves = 6)
```

### Curl (of a Spatial) Noise (Pattern) Exercises

The curl-art-1.R and curl-art-2.R scripts contain code to generate the “small grid of fractal walks” image and the “genesis-inspired” image. In both cases the ouput is written to a 2000x2000 pixel png file, and the time taken to complete the task printed to the screen.

Exercise:

1.  Run both scripts, and compare the difference in rendering times

```{r}
#load new package
library(tictoc)

#answer: the first code chunk takes 0.422 sec while the second takes longer at 2.91 sec 

#curl-art-1.R code and set iteratons 
curl_data <- function(data, iterations = 50, step_size = .001,
    ...
) {
  #update new object name and again use function 
  update <- function(current_state, iteration, ...) {
    #use curl_noise to change how the figure looks and set x and y
    curl <- curl_noise(x = current_state$x, y = current_state$y, generator = fracture,
      ...
    )
    #set new object name and continue to pipe
    next_state <- current_state |>
      #mutate and set x and y and also time plus one
      mutate(x = x + curl$x * step_size, y = y + curl$y * step_size, time = time + 1
      )
    #tell R what to return
    return(next_state)
  }
  #set data and mutate it
  data |> 
    #mutate by row and time
    mutate(id = row_number(), time = 1) |>
    #use new accumulate function to set iterations
    accumulate(1:iterations, update, .init = _, ...) |>
    #bind all the rows together
    bind_rows()
}

#new object name and again use of function but nothing inside
curl_art <- function(...) {
  #curl data again and set ggplt
  curl_data(...) |> 
    #define aesthetics and group 
    ggplot(aes(x, y, group = id)) + 
    #set geom of choice for data 
    geom_path() +
    #blank theme
    theme_void() + 
    #set coordinates
    coord_equal() 
}

#set small grid and long_grid to identify size
smol_grid <- long_grid(x = 1:20, y = 1:20)

#assign to pic objectname 
pic <- smol_grid |>
  #mutate data and normalise it by x and y 
  mutate(x = normalise(x), y = normalise(y)) |>
  #pipe in the curl art again and add in fractal and octave information 
  curl_art(noise = gen_simplex, fractal = fbm, octaves = 4, freq_init = .5)

#time it takes
tic()

#curl-art-2.R code and set iterations adn setp size again
curl_data <- function(data, iterations = 50, step_size = .001,
    ...
) {
  #update the code new object name
  update <- function(current_state, iteration, ...) {
    #curl function again and generator function 
    curl <- curl_noise(x = current_state$x, y = current_state$y, generator = fracture,
      ...
    )
    #set next state as current state and pipe in 
    next_state <- current_state |>
      #pipe in the mutate function to the information 
      mutate(x = x + curl$x * step_size, y = y + curl$y * step_size, time = time + 1
      )
    #return output of next_state
    return(next_state)
  }
  #new pipe for data
  data |> 
    #mutate again by row and time
    mutate(id = row_number(), time = 1) |>
    #pipe in accumulate function for iterations
    accumulate(1:iterations, update, .init = _, ...) |>
    #bind the rows together
    bind_rows()
}

#curl art again function
curl_art <- function(...) {curl_data(...) |> 
    #new ggplot and set aesthetics
    ggplot(aes(x, y, group = id)) + 
    #set geom of choice
    geom_path() +
    #set blank theme
    theme_void() + 
    #set coordinates
    coord_equal() 
}
#set custom data using function again
custom_curl_data <- function(data) {
  #set critical information for what will be used and show with octaves, fractals, etc as usual
  curl_data(data = data, iterations = 80, octaves = 10, fractal = ridged, noise = gen_cubic, freq_init = 1, frequency = ~ . * 1.2, gain_init = 1, gain = ~ . * .9, seed = 1
  )
}

#assign new object name and set number of n
circle <- function(n = 100) {
   #using tible again and multiply by pi and divide by n
   tibble(theta = 2 * pi * (1:n) / n, x = cos(theta), y = sin(theta)
  )
}

#assign new object name and select circle value
dat1 <- circle(5000) |> 
  #call data
  custom_curl_data()

#assign new object name and select circle value
dat2 <- circle(5000) |>
  #mutate data
  mutate(x = x * .99, y = y * .99) |>
  #call data
  custom_curl_data()

#call new object name to be new ggplot 
pic <- ggplot(mapping = aes(x, y, group = time)) +
  #select geom of interest
  geom_polygon(data = dat1, fill = "#ffffff10") +
  #select geom of interest
  geom_polygon(data = dat2, fill = "#22222205") +
  #blank theme
  theme_void() +
  #set coordinates
  coord_equal()

#time it takes
tic()
#save document to specific file name 
ggsave(filename = here("output", "curl-art-2.png"), 
  #settings for the output file when it is done
  plot = pic, width = 2000, height = 2000, units = "px", dpi = 300, bg = "white"
)
#time it takes
toc()
```

2.  Modify the “small grid” version so that it produces smoother looking results.

```{r}
#modify the curl data iterations
curl_data <- function(data, iterations = 50, step_size = .001,
    ...
) {
  #update the function to current_state and iteration
  update <- function(current_state, iteration, ...) {
    #set curl x and y 
    curl <- curl_noise(x = current_state$x, y = current_state$y, enerator = fracture,
      ...
    )
    #set next state and pipe into current 
    next_state <- current_state |>
      #mutate using x and y and set time
      mutate(x = x + curl$x * step_size, y = y + curl$y * step_size, time = time + 1
      )
    #return output
    return(next_state)
  }
  #new pipe for data
  data |> 
    #mutate again by row number and ste time
    mutate(id = row_number(), time = 1) |>
    #accumulate using iterations 
    accumulate(1:iterations, update, .init = _, ...) |>
    #bind rows together
    bind_rows()
}

#another curl_art and function is empty
curl_art <- function(...) {
  #curl data also empty then pipe
  curl_data(...) |> 
    #ggplot with new x and y and group
    ggplot(aes(x, y, group = id)) + 
    #set geom
    geom_path() +
    #set blank theme
    theme_void() + 
    #set axis coordinates
    coord_equal() 
}

#use small grid and assignment to long grid and set
smol_grid <- long_grid(x = 1:20, y = 1:20)


#time it takes
tic()
#save file 
ggsave(
  #assign name to file 
  filename = here("output", "curl-art-1.png"), 
  #set information for how the output will be and dimensions
  plot = pic,
  width = 2000,
  height = 2000,
  units = "px",
  dpi = 300,
  bg = "white"
)
#time it takes
toc()
#show the output
plot(pic)
```

3.  Explore what you can do with the “genesis style”. It’s a powerful technique that can do a lot more than I’ve done in this code. By now you should have a good sense of what dials you can turn: the fractal, the generator, the parameters, the palette, etc. You can use dplyr to modify the data if you want to. Try to make something you really like!

```{r}
#use new object name and function use data
custom_curl_data <- function(data) {
  #set data and iterations and octaves
  curl_data(data = data, iterations = 4, octaves = 8,
    #change the fractal to be fbm not rigid
    fractal = fbm, noise = gen_cubic, freq_init = 5, frequency = ~ . * 3,
    #change gain and seed values
    gain_init = 2, gain = ~ . * .5, seed = 79
  )
}

#create new plot and set aesthetics and group
ggplot(mapping = aes(x, y, group = time)) +
  #set polygon geom and color outline pink
  geom_polygon(data = dat1, fill = "hotpink") +
  #color the inside in gray 
  geom_polygon(data = dat2, fill = "#22222210") +
  #blank theme
  theme_void() + 
  #coordinates set
  coord_equal()
```

## Part 2d: Art Of Your Choice: Iterated Function Systems

```{r}
#load in needed packages
library(Rcpp)
library(ggplot2)
library(tibble)
library(purrr)
library(dplyr)
library(ggthemes)
library(tictoc)
```

### Some Tiresome Formalism Exercise

Exercise: Code for this system is included in the barnsley-fern.R script.

```{r}
#add in new object and function for coord
fern_transform <- function(coord, ind) {
  # coefficients for the stem function f_1
  if(ind == 1) {
    #matrix to multiply
    mat <- matrix(c(0, 0, 0, .16), 2, 2) 
    #offset vector to add
    off <- c(0, 0)                       
  }
  #coefficients for the small leaflet function f_2
  if(ind == 2) {
    #matrix to multiply
    mat <- matrix(c(.85, -.04, .04, .85), 2, 2)
    #offset vector to add
    off <- c(0, 1.6)                      
  }
  #coefficients for the right-side function f_3
  if(ind == 3) {
    #matrix to multiply
    mat <- matrix(c(.2, .23, -.26, .22), 2, 2)
    #offset vector to add
    off <- c(0, 1.6)                      
  }
  
  #coefficients for the left-side function f_4
  if(ind == 4) {
    #matrix to multiply
    mat <- matrix(c(-.15, .26, .28, .24), 2, 2)
    #offset vector to add
    off <- c(0, .44)                     
  }
  
  #return the affine transformed coords
  coord <- mat %*% coord + off
  return(coord)
}

#new object and set iterations different and seed null
fern_chaos <- function(iterations = 10000, seed = NULL) {
  #set seed information
  if(!is.null(seed)) set.seed(seed)
  
  #which transformation to apply at each iteration
  transform_index <- sample(x = 1:4, 
    #set size and replace and prob
    size = iterations, replace= TRUE, prob = c(.01, .85, .07, .07)
  )
  
  #initialise chaos game at the origin
  start <- matrix(c(0, 0))
  
  # helper function to collapse accumulated output
  bind_to_column_matrix <- function(lst) {
    #bind the data
    do.call(cbind, lst)
  }
  
  # iterate until done!
  coord_matrix <- transform_index |>
    #accumulate the data and start
    accumulate(fern_transform, .init = start) |>
    #bind the data to the new object
    bind_to_column_matrix() 
  
  # tidy the output, add extra columns, and return
  coord_df <- t(coord_matrix) |> 
    #lead to data
    as.data.frame() 
  #set coord for x and y 
  names(coord_df) <- c("x", "y")
  #new pipe for coord_df
  coord_df <- coord_df |>
    #new tibble and mutate below
    as_tibble() |>
    #mutate transform and iteration
    mutate(transform = c(0, transform_index), iteration = row_number() - 1
    )
  #return output
  return(coord_df)
}
#fern data and seed choose
fern_dat <- fern_chaos(seed = 1)
#pic object for ggplot and fern set aesthetics
pic <- ggplot(fern_dat, aes(x, y, colour = iteration)) +
  #set geom and size and stroke
  geom_point(size = 1, stroke = 0) +
  #set coordinates
  coord_equal() +
  #blank theme
  theme_void() + 
  #set guides for legend color
  guides(colour = guide_legend(
    title = "transformation", 
    #override the list and set size
    override.aes = list(size = 5))
  )
#show the plot of pic
plot(pic)
```

### Chaos Game for the Barnsley Fern Exercise

Exercise: Code for this system is included in the unbox-base.R script.

```{r}
#new object name and seed again and set n at 4
sample_canva2 <- function(seed = NULL, n = 4) {
  #set random generation
  if(!is.null(seed)) set.seed(seed)
  #set themes for palettes
  sample(ggthemes::canva_palettes, 1)[[1]] |>
    (\(x) colorRampPalette(x)(n))()  
}
#set list and assign to new object
funs <- list(
  #use function and point to sum data
  function(point) point + (sum(point ^ 2)) ^ (1/3),
  #use sin of the point
  function(point) sin(point),
  #multiply by 2
  function(point) 2 * sin(point)
)
#use function and iterations and layers
unboxer_base <- function(iterations, layers, seed = NULL) {
  #random seed generation
  if(!is.null(seed)) set.seed(seed)
  
  #coefficients defining affine layer transforms, A_i
  coeffs <- array(
    #select data and min and max
    data = runif(9 * layers, min = -1, max = 1), 
    #set dimensions
    dim = c(3, 3, layers)
  )
  
  #list of variant functions, g_j
  funs <- list(
    #funtion and sum
    function(point) point + (sum(point ^ 2)) ^ (1/3),
    #function and sin of point
    function(point) sin(point),
    #functiona and multiply sin of point
    function(point) 2 * sin(point)
  )
  
  #updater function: apply the layer, then the function
  #(the weirdness with point[3] is me treating colour as special)
  update <- function(point, layer, transform) {
    #transform function
    f <- funs[[transform]]
    #transform point to 3
    z <- point[3]
    #assign point
    point[3] <- 1
    #assignemt of point and coeff
    point <- f(point %*% coeffs[,,layer])
    #another point and divide by 2
    point[3] <- (point[3] + z)/2
    #show output
    return(point)
  }
  
  #set initial point and matrix data and min and max and rows and columns
  point0 <- matrix(data = runif(3, min = -1, max = 1), nrow = 1, ncol = 3
  )
  
  #sample points
  layer_ind <- sample(layers, iterations, replace = TRUE)  
  #sample lenghts
  trans_ind <- sample(length(funs), iterations, replace = TRUE)  
  #accumulate layers
  points <- accumulate2(layer_ind, trans_ind, update, .init = point0)
  
  # tidy up, add columns, and return
  points <- matrix(unlist(points), ncol = 3, byrow = TRUE)
  #bind points
  points <- cbind(points, c(0, layer_ind), c(0, trans_ind)
  )
  #show output
  return(points)
}
#unbox the data and set seed and size
unbox_art <- function(data, seed = NULL, size = 1) {
  
  #convert to data frame and sample a palette
  data <- data |> as.data.frame() |> as_tibble()
  #set names and data
  names(data) <- c("x", "y", "c", "l", "t")[1:ncol(data)]
  #set shades
  shades <- sample_canva2(seed)
  
  #render image as a scatter plot
  ggplot(data, aes(x, y, colour = c)) +
    #geom point information
    geom_point(
      size = size,
      stroke = 0,
      show.legend = FALSE
    ) + 
    #blank theme
    theme_void() + 
    #coordinate limits
    coord_equal(xlim = c(-4, 4), ylim = c(-4, 4)) + 
    #color gradient settings
    scale_colour_gradientn(colours = shades) + 
    #set scales for x and y 
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    #adjust theme 
    theme(panel.background = element_rect(fill = shades[1], colour = shades[1]
    ))
}
#time it takes
tic()
#set seed and layers
seed <- 1234
layers <- 5
#assign pic as new object and set base and layers and seed and unbox
pic <- unboxer_base(1000000, layers = layers, seed = seed) |> 
  unbox_art(seed = seed, size = .2) 
#set paste0 and layers and seed information and as png
fname <- paste0("unboxer-base-", layers, "-", seed, ".png")
#save file 
ggsave(
  filename = here("output", fname), 
  plot = pic,
  width = 2000,
  height = 2000,
  units = "px",
  dpi = 300
)
#time
toc()
#show pic
plot(pic)
```

## Part 2e: Pull It All Together

Create 3 art pieces that combines elements of what you learned from parts b-d.

### Art Piece 1
```{r, warning=FALSE}

#function to generate random palettes
sample_canva <- function(seed = NULL) {
  #set to random seed generation
  if(!is.null(seed)) set.seed(seed)
  #select sample of canva_palettes
  sample(ggthemes::canva_palettes, 98)[[98]]
}

#generate the spatial noise data
generate_spatial_data <- function(seed_spatial, freq_spatial) {
  #set x coordinates and lenght
  x_coords <- seq(from = 0, to = 1, length.out = 600)
  #set y coordinates and lenght
  y_coords <- seq(from = 0, to = 1, length.out = 600)
  #set canvas to long_grid and coordinates
  canvas <- long_grid(x = x_coords, y = y_coords)
  #set dat and pipe in the mutate function
  dat <- canvas |> 
    #mutate data set x and y assignemtns
    mutate(paint = gen_simplex(x = x, y = y, 
        #set freuency and seed information
        frequency = freq_spatial, seed = seed_spatial
      )
    )
  #return information 
  return(dat)
}

#function to create the mtcars figure with integrated spatial data and black borders
mtcars_figure <- function(seed, n, palette, seed_spatial, freq_spatial, fern_points) {
  #set the state of the random number generator
  set.seed(seed)
  
  #generate the spatial data
  spatial_data <- generate_spatial_data(seed_spatial, freq_spatial)
  
  #data frame containing random values for aesthetics
  dat <- tibble(
    #set x and y values using runif command
    x0 = runif(n), y0 = runif(n),
    #set x min and max values
    x1 = x0 + runif(n, min = -.2, max = .2),
    #set y min and max values
    y1 = y0 + runif(n, min = -.2, max = .2),
    #set expectations for shade, size, and paint of tibble
    shade = runif(n), size = runif(n),paint = sample(spatial_data$paint, n)
  )

  
  #plot segments with a black border in various colors using the generated palette
  plot <- dat |> 
    #set ggplot x and y in aesthetics 
    ggplot(aes(x = x0, y = y0, xend = x1, yend = y1,
      #set information for color, size, and fill of plot
      colour = shade, size = size, fill = paint
    )) +
    #add in geom_segment to show data and don't show legend
    geom_segment(show.legend = FALSE) +  
    #add in geom_raster to show data this way too and no legend
    geom_raster(show.legend = FALSE) +
    #set coordinates for plot size
    coord_equal() +
    #set y axis 
    scale_y_continuous(expand = c(0, 0)) +
    #set x axis 
    scale_x_continuous(expand = c(0, 0)) + 
    #set color gradient using color palette
    scale_colour_gradientn(colours = palette) + 
    #set the size to range from 0 to 10
    scale_size(range = c(0, 10)) + 
    #fill the color with seed_spatial from sample_canva from above
    scale_fill_gradientn(colours = sample_canva(seed_spatial)) +
    #set blank theme
    theme_void() 
  
  #add the fern points as an additional layer
  plot <- plot + 
    #add in data using geom_point and identify x and y data points, set color, and transparency
    geom_point(data = fern_points, aes(x = x / 10, y = y / 10), color = "skyblue4", size = 0.2, alpha = 0.7, inherit.aes = FALSE)
  #show the plot
  return(plot)
}

#function to generate Barnsley fern points
fern_transform <- function(coord, ind) {
   #edit the exact matrix of the fern data
   if(ind == 1) {
    mat <- matrix(c(0, 0, 0, .16), 2, 2)
    off <- c(0, 0)
   }
  #continue to edit the matrix of the fern data
  if(ind == 2) {
    mat <- matrix(c(.85, -.04, .04, .85), 2, 2)
    off <- c(0, 1.6)
  }
  #continue to edit the matrix of the fern data
  if(ind == 3) {
    mat <- matrix(c(.2, .23, -.26, .22), 2, 2)
    off <- c(0, 1.6)
  }
  #continue to edit the matrix of the fern data
  if(ind == 4) {
    mat <- matrix(c(-.15, .26, .28, .24), 2, 2)
    off <- c(0, .44)
  }
  #edit the coordinates of the matrices
  coord <- mat %*% coord + off
  #return the output we want
  return(coord)
}

#create the plot setting up by defining the number for iterations and the seed number
fern_chaos <- function(iterations = 10000, seed = NULL) {
  #set up random seed generation method 
  if(!is.null(seed)) set.seed(seed)
  #use transform function for x values and replace using iterative function
  transform_index <- sample(x = 1:4, 
    #set size as iterations, set replace commend and prob with string 
    size = iterations, replace= TRUE, prob = c(.01, .85, .07, .07)
  )
  #set starting matrix
  start <- matrix(c(0, 0))
  #bind matrices together
  bind_to_column_matrix <- function(lst) {
    do.call(cbind, lst)
  }
  #set coordinates for matrix and utilize transform_index
  coord_matrix <- transform_index |>
    #use accumulate function with ferm_transform data
    accumulate(fern_transform, .init = start) |>
    #bind matrices
    bind_to_column_matrix() 
  #repeat process from above
  coord_df <- t(coord_matrix) |> 
    #repeat process from above
    as.data.frame() 
  #repeat process from above
  names(coord_df) <- c("x", "y")
  #repeat process from above using tibble 
  coord_df <- coord_df |>
    #apply tibble function for this case
    as_tibble() |>
    #mutate data to transform it by iteration through row numbers minus 1
    mutate(
      transform = c(0, transform_index),
      iteration = row_number() - 1
    )
  #return output
  return(coord_df)
}

#generate a small number of fern points
fern_points <- fern_chaos(iterations = 500, seed = 1)

#get parameters
seed <- 45
#set number
n <- 40
#define palette of choice
palette <- c("grey90", "cadetblue4", "lightblue", "lightblue3", "grey95", "skyblue4")
#set seed spatial
seed_spatial <- 100
#set frequency of spatial information
freq_spatial <- 10

#create the mtcars figure
mtcars_seed <- mtcars_figure(seed = seed, n = n, palette = palette, seed_spatial = seed_spatial,
                             #set frequency of data and include in ferm_points information 
                             freq_spatial = freq_spatial, fern_points = fern_points)

#plot the mtcars figure
plot(mtcars_seed)
```
**Figure 1 Caption:**
Figure 1 Title: A fern admist chaos. Figure created: 06-4-24. Inspiration: I was inspired to create this piece because I was really drawn to both the geometric shapes within the introductory lesson as well as the concept of being able to create artwork resembling nature within a technology like R Studio. I thought it would be fun to combine the two ideas of something that looks more technical with something that resembles nature to have an artistic juxtaposition. Specific Components: I utilized the random palette generator from the introductory exercises (part b) to get randomized data for the art piece as well as using the tibble function to create a new dataframe for these random values and set aesthetics. From part c which focused on spatial noise I used the method of generating spatial noise data, setting frequencies and seeds. Finally, from part d which focused on iterated function systems I included a smaller blue figure of a fern on top of the existing artpiece to create dimension through the Barnsley fern points method, setting up matrices and generating iterations.

### Art Piece 2
```{r, warning=FALSE}
#FROM PART B using the sample_canvas object and setting n and seed
sample_canva2 <- function(seed = NULL, n = 4) {
  #random number generation
  if(!is.null(seed)) set.seed(seed)
  #select sample using canva palettes and color ramp
  sample(ggthemes::canva_palettes, 1)[[1]] |>
    (\(x) colorRampPalette(x)(n))()  
}

#FROM PART D using unbox object and setting seed and size
unbox_art <- function(data, seed = NULL, size = 1) {
  
  #convert to data frame and sample a palette
  data <- data |> as.data.frame() |> as_tibble()
  #set names using vector of options
  names(data) <- c("x", "y", "c", "l", "t")[1:ncol(data)]
  #set shades to sample_canva2 seed
  shades <- sample_canva2(seed)
  
  #render image as a scatter plot
  ggplot(data, aes(x, y, colour = c)) +
    #select geom point and set size and stroke and disable legend
    geom_point(
      size = size,
      stroke = 0,
      show.legend = FALSE
    ) + 
    #FROM PART C - geom_polygon used in this case to add to existing ggplot
    geom_polygon(
      #set size and stroke and disable legend here too
      size = size, 
      stroke = 0, 
      show.legend = FALSE) + 
    #blank them
    theme_void() + 
    #change coordinates limits
    coord_equal(xlim = c(-4, 4), ylim = c(-4, 4)) + 
    #set color gradients
    scale_colour_gradientn(colours = shades) + 
    #set x and y axis
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    #adjust theme for panel background
    theme(panel.background = element_rect(
      fill = shades[1], colour = shades[1]
    ))
}
#adjust number here
mil <- 1000
#time
tic()
#use this to select layers and seed and then unbox
unboxer_base(3 * mil, layers = 3, seed = 2) |> 
  unbox_art(seed = 2, size = .9)
```
**Figure 2 Caption:**
Figure 2 Title: Spiderweb Void. Figure created: 06-4-24. Inspiration: I was inspired to create this piece because I wanted to see what I would be able to do without using colors to define the artwork. I really liked what Danielle Navarro did with one of her figures from the iterated function systems where she created art that looked like a cloud of smoke, and I wanted to create something that was inspried by this but more geometric. Specific Components: I utilized the sample_canva code from part b to set up my random seed generation for the rest of the code for the figure. Additionally, I used the geom_polygon function which we used in part c within the spatial noise exercises and added that to my ggplot to create a more dynamic figure. Lastly, I incorporated the code from part d (iterated function systems) via the ggplot code and the unboxer_base method. 

### Art Piece 3

```{r, warning=FALSE}
library(ggplot2)

#FROM PART B - introductory exercises selecting my favorite colors to use later
pal <- c("#cdb4db", "#ffc8dd", "#ffafcc", "#bde0fe", "#a2d2ff")

#FROM PART C - spatial noise tricks using smol_grid function
smol_simplex <- smol_grid |>
  #using mutate to set seed and frequency
  mutate(z = gen_simplex(x, y, seed = 1, frequency = .1)) 

#again using smol_simplex
smol_simplex |>
  #assignment of x and y in ggplot 
  ggplot(aes(x, y, z = z)) + 
  #change to geom_tile() for more regular rasterization
  geom_tile(aes(fill = z)) +  
  #FROM PART D - iterative function systems to add in white dots to the figure! 
  geom_point(colour = "white", size = 0.6, stroke = 0) + 
  #set scales to be continuous and expand them for x and y 
  scale_y_continuous(expand = c(0, 5)) +
  scale_x_continuous(expand = c(0, 5)) + 
  #FROM PART B - introductory exercises changing the color gradient to the palette we originally created
  scale_fill_gradientn(colors = pal, 
                       #setting guide so we don't see any legend showing up 
                       guide = "none") +  
  #setting blank theme
  theme_void() + 
  #setting coord requirements to standard
  coord_equal() 
```
**Figure 3 Caption:** 
Figure 3 Title: Cotton-Candy Code. Figure created: 06-4-24. Inspiration: For my final artpiece I really wanted to focus on color, specifically utilizing a color palette that I curated myself and really liked. I though that the combination of pink and blue was a fun representation of the colors of cotton-candy. Specific Components: I selected my palette using references to code from part b the introductory lesson. Additionally, I used spatial noise tricks from part c to create the grid-like shape of the piece and the general ggplot. Lastly, I used the geom_point and specifically stroke function from part d of iterative function systems to add in little white dots and add dimension to the figure. 

## Summary 

Overall, this process was really difficult for me. So far in the course I have felt relatively confident in my coding abilities and this assignment was very difficult for me. Working through this, so much of it seemed foreign to me that I felt like I was learning an entirely new programming software. My biggest takeaway was that R studio has a much greater capacity than what I had originally thought. I was completely unaware of all of the new programming methods and functions and honestly suprised by the level of creativity I was able to have in what I thought was a much more rigid software. Creating the artwork was a totally new process for me, as the closest I have ever come to doing something similar is working on making a ggplot pretty with different colors and themes. I learned that there is so much more to R than I can possibly be aware of and that no matter how much I think I know I will always been continuing to learn when working with R. The exercises were honestly very difficult for me and I was really struggling to understand certain parts of the process, especially I think because the way the code was formatted was more spread out than what I am used to, so it was tougher for me to see where one function ended and another began. Overall, my main takeaway was that this was really challenging, but I definetly learned new things. 



